#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Spectrum Similarity Analysis Tool - For analyzing spectrum similarity of images generated by diffusion model at adjacent steps
Usage: python spectrum_analyzer.py image1.jpg image2.jpg
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from scipy import fft
from skimage import metrics
import argparse
import os
import sys

class SpectrumAnalyzer:
    def __init__(self):
        self.results = {}
        
    def load_image(self, image_path):
        """Load image and convert to grayscale"""
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Image file does not exist: {image_path}")
            
        img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        if img is None:
            raise ValueError(f"Unable to read image: {image_path}")
            
        return img
    
    def get_frequency_spectrum(self, img):
        """Get frequency spectrum of the image"""
        # Perform 2D Fourier Transform
        f_transform = fft.fft2(img)
        f_shift = fft.fftshift(f_transform)  # Move zero frequency to center
        
        # Calculate magnitude spectrum and phase spectrum
        magnitude_spectrum = np.abs(f_shift)
        phase_spectrum = np.angle(f_shift)
        
        # Logarithmic transformation for visualization
        log_spectrum = np.log(magnitude_spectrum + 1)
        
        return f_shift, magnitude_spectrum, phase_spectrum, log_spectrum
    
    def analyze_spectrum_similarity(self, mag_spec1, mag_spec2):
        """Analyze spectrum similarity"""
        results = {}
        
        # Method 1: Structural Similarity Index (SSIM)
        results['SSIM'] = metrics.structural_similarity(
            mag_spec1, mag_spec2, data_range=mag_spec1.max() - mag_spec1.min()
        )
        
        # Method 2: Normalized Cross-Correlation
        results['Correlation'] = np.corrcoef(
            mag_spec1.flatten(), mag_spec2.flatten()
        )[0, 1]
        
        # Method 3: Mean Squared Error (MSE)
        results['MSE'] = np.mean((mag_spec1 - mag_spec2) ** 2)
        
        # Method 4: Normalized Mean Squared Error (NMSE)
        results['NMSE'] = results['MSE'] / (np.mean(mag_spec1**2) + 1e-8)
        
        # Method 5: Cosine Similarity
        dot_product = np.sum(mag_spec1.flatten() * mag_spec2.flatten())
        norm1 = np.linalg.norm(mag_spec1.flatten())
        norm2 = np.linalg.norm(mag_spec2.flatten())
        results['Cosine_Similarity'] = dot_product / (norm1 * norm2 + 1e-8)
        
        return results
    
    def analyze_frequency_bands(self, mag_spec1, mag_spec2):
        """Analyze similarity of different frequency bands"""
        h, w = mag_spec1.shape
        center = (h//2, w//2)
        y, x = np.ogrid[:h, :w]
        distances = np.sqrt((x - center[1])**2 + (y - center[0])**2)
        
        max_radius = min(h, w) // 2
        
        # Define frequency bands
        low_freq_mask = distances <= max_radius // 3
        mid_freq_mask = (distances > max_radius // 3) & (distances <= 2 * max_radius // 3)
        high_freq_mask = distances > 2 * max_radius // 3
        
        def get_band_energy(spectrum, mask):
            return np.sum(spectrum[mask])
        
        # Calculate energy for each frequency band
        low1 = get_band_energy(mag_spec1, low_freq_mask)
        mid1 = get_band_energy(mag_spec1, mid_freq_mask)
        high1 = get_band_energy(mag_spec1, high_freq_mask)
        total1 = low1 + mid1 + high1
        
        low2 = get_band_energy(mag_spec2, low_freq_mask)
        mid2 = get_band_energy(mag_spec2, mid_freq_mask)
        high2 = get_band_energy(mag_spec2, high_freq_mask)
        total2 = low2 + mid2 + high2
        
        # Calculate similarity for each frequency band
        results = {
            'Low_Freq_Energy_Ratio1': low1 / (total1 + 1e-8),
            'Mid_Freq_Energy_Ratio1': mid1 / (total1 + 1e-8),
            'High_Freq_Energy_Ratio1': high1 / (total1 + 1e-8),
            'Low_Freq_Energy_Ratio2': low2 / (total2 + 1e-8),
            'Mid_Freq_Energy_Ratio2': mid2 / (total2 + 1e-8),
            'High_Freq_Energy_Ratio2': high2 / (total2 + 1e-8),
        }
        
        # Calculate frequency band similarity
        results['Low_Freq_Similarity'] = 1 - abs(results['Low_Freq_Energy_Ratio1'] - results['Low_Freq_Energy_Ratio2'])
        results['Mid_Freq_Similarity'] = 1 - abs(results['Mid_Freq_Energy_Ratio1'] - results['Mid_Freq_Energy_Ratio2'])
        results['High_Freq_Similarity'] = 1 - abs(results['High_Freq_Energy_Ratio1'] - results['High_Freq_Energy_Ratio2'])
        
        return results
    
    def diffusion_specific_analysis(self, img1, img2, mag_spec1, mag_spec2):
        """Diffusion model specific analysis"""
        results = {}
        
        # 1. High frequency noise change analysis
        h, w = mag_spec1.shape
        center = (h//2, w//2)
        y, x = np.ogrid[:h, :w]
        distances = np.sqrt((x - center[1])**2 + (y - center[0])**2)
        
        # High frequency region (noise is usually concentrated in high frequency)
        high_freq_mask = distances > min(h, w) // 4
        
        high_freq_energy1 = np.sum(mag_spec1[high_freq_mask])
        high_freq_energy2 = np.sum(mag_spec2[high_freq_mask])
        
        results['High_Freq_Energy1'] = high_freq_energy1
        results['High_Freq_Energy2'] = high_freq_energy2
        results['Noise_Reduction_Ratio'] = (high_freq_energy1 - high_freq_energy2) / (high_freq_energy1 + 1e-8)
        
        # 2. Spectral smoothness analysis
        def compute_spectral_smoothness(spectrum):
            grad_y, grad_x = np.gradient(spectrum)
            roughness = np.mean(np.sqrt(grad_y**2 + grad_x**2))
            return 1 / (1 + roughness)
        
        results['Spectral_Smoothness1'] = compute_spectral_smoothness(mag_spec1)
        results['Spectral_Smoothness2'] = compute_spectral_smoothness(mag_spec2)
        results['Smoothness_Improvement'] = results['Spectral_Smoothness2'] - results['Spectral_Smoothness1']
        
        # 3. Image quality metrics
        results['Image_MSE'] = np.mean((img1.astype(float) - img2.astype(float)) ** 2)
        results['Image_PSNR'] = 20 * np.log10(255 / (np.sqrt(results['Image_MSE']) + 1e-8))
        results['Image_SSIM'] = metrics.structural_similarity(img1, img2)
        
        return results
    
    def visualize_results(self, img1, img2, log_spec1, log_spec2, mag_spec1, mag_spec2, save_path=None):
        """Visualize analysis results"""
        plt.figure(figsize=(20, 12))
        
        # Original images
        plt.subplot(3, 4, 1)
        plt.imshow(img1, cmap='gray')
        plt.title('Original Image 1 (Step t)', fontsize=12)
        plt.axis('off')
        
        plt.subplot(3, 4, 2)
        plt.imshow(img2, cmap='gray')
        plt.title('Original Image 2 (Step t+1)', fontsize=12)
        plt.axis('off')
        
        # Image difference
        plt.subplot(3, 4, 3)
        diff_img = np.abs(img1.astype(float) - img2.astype(float))
        plt.imshow(diff_img, cmap='hot')
        plt.title('Image Difference', fontsize=12)
        plt.colorbar()
        plt.axis('off')
        
        # Image histogram
        plt.subplot(3, 4, 4)
        plt.hist(img1.flatten(), bins=50, alpha=0.7, label='Image 1', color='blue')
        plt.hist(img2.flatten(), bins=50, alpha=0.7, label='Image 2', color='red')
        plt.title('Pixel Value Distribution')
        plt.legend()
        plt.xlabel('Pixel Value')
        plt.ylabel('Frequency')
        
        # Spectrum plots
        plt.subplot(3, 4, 5)
        plt.imshow(log_spec1, cmap='gray')
        plt.title('Spectrum 1 (Step t)', fontsize=12)
        plt.axis('off')
        
        plt.subplot(3, 4, 6)
        plt.imshow(log_spec2, cmap='gray')
        plt.title('Spectrum 2 (Step t+1)', fontsize=12)
        plt.axis('off')
        
        # Spectrum difference
        plt.subplot(3, 4, 7)
        diff_spectrum = np.abs(mag_spec1 - mag_spec2)
        plt.imshow(np.log(diff_spectrum + 1), cmap='hot')
        plt.title('Spectrum Difference', fontsize=12)
        plt.colorbar()
        plt.axis('off')
        
        # Radial spectrum profile
        plt.subplot(3, 4, 8)
        h, w = mag_spec1.shape
        center = (h//2, w//2)
        y, x = np.ogrid[:h, :w]
        r = np.sqrt((x - center[1])**2 + (y - center[0])**2).astype(int)
        
        max_r = min(center)
        radial_profile1 = np.zeros(max_r)
        radial_profile2 = np.zeros(max_r)
        
        for radius in range(max_r):
            mask = r == radius
            if np.any(mask):
                radial_profile1[radius] = np.mean(mag_spec1[mask])
                radial_profile2[radius] = np.mean(mag_spec2[mask])
        
        plt.plot(radial_profile1, label='Spectrum 1', alpha=0.8)
        plt.plot(radial_profile2, label='Spectrum 2', alpha=0.8)
        plt.title('Radial Spectrum Profile')
        plt.xlabel('Distance from Center (pixels)')
        plt.ylabel('Average Magnitude')
        plt.legend()
        plt.yscale('log')
        
        # Frequency band energy distribution
        plt.subplot(3, 4, 9)
        band_results = self.analyze_frequency_bands(mag_spec1, mag_spec2)
        bands = ['Low Freq', 'Mid Freq', 'High Freq']
        ratios1 = [band_results['Low_Freq_Energy_Ratio1'], 
                   band_results['Mid_Freq_Energy_Ratio1'],
                   band_results['High_Freq_Energy_Ratio1']]
        ratios2 = [band_results['Low_Freq_Energy_Ratio2'], 
                   band_results['Mid_Freq_Energy_Ratio2'],
                   band_results['High_Freq_Energy_Ratio2']]
        
        x = np.arange(len(bands))
        width = 0.35
        
        plt.bar(x - width/2, ratios1, width, label='Image 1', alpha=0.8)
        plt.bar(x + width/2, ratios2, width, label='Image 2', alpha=0.8)
        plt.title('Frequency Band Energy Distribution')
        plt.xlabel('Frequency Band')
        plt.ylabel('Energy Ratio')
        plt.xticks(x, bands)
        plt.legend()
        
        # Similarity metrics radar chart
        plt.subplot(3, 4, 10)
        similarity_results = self.analyze_spectrum_similarity(mag_spec1, mag_spec2)
        metrics_names = list(similarity_results.keys())
        metrics_values = [abs(v) if k == 'MSE' or k == 'NMSE' else v for k, v in similarity_results.items()]
        
        # Normalize MSE metric for display
        if 'MSE' in similarity_results:
            mse_idx = metrics_names.index('MSE')
            metrics_values[mse_idx] = 1 / (1 + similarity_results['MSE'] / 1000)  # Normalize MSE
        if 'NMSE' in similarity_results:
            nmse_idx = metrics_names.index('NMSE')
            metrics_values[nmse_idx] = 1 / (1 + similarity_results['NMSE'])  # Normalize NMSE
            
        angles = np.linspace(0, 2 * np.pi, len(metrics_names), endpoint=False).tolist()
        metrics_values += metrics_values[:1]  # Close the shape
        angles += angles[:1]
        
        ax = plt.subplot(3, 4, 10, projection='polar')
        ax.plot(angles, metrics_values, 'o-', linewidth=2)
        ax.fill(angles, metrics_values, alpha=0.25)
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(metrics_names, fontsize=8)
        ax.set_ylim(0, 1)
        plt.title('Similarity Metrics', fontsize=12)
        
        # Display analysis results text in remaining space
        plt.subplot(3, 4, 11)
        plt.axis('off')
        
        # Prepare text display
        text_content = []
        text_content.append("=== Spectrum Similarity Analysis Results ===\n")
        
        for key, value in similarity_results.items():
            text_content.append(f"{key}: {value:.4f}")
        
        text_content.append("\n=== Frequency Band Similarity ===")
        text_content.append(f"Low Freq Similarity: {band_results['Low_Freq_Similarity']:.4f}")
        text_content.append(f"Mid Freq Similarity: {band_results['Mid_Freq_Similarity']:.4f}")
        text_content.append(f"High Freq Similarity: {band_results['High_Freq_Similarity']:.4f}")
        
        diffusion_results = self.diffusion_specific_analysis(img1, img2, mag_spec1, mag_spec2)
        text_content.append("\n=== Diffusion Specific Analysis ===")
        text_content.append(f"Noise Reduction Ratio: {diffusion_results['Noise_Reduction_Ratio']:.4f}")
        text_content.append(f"Smoothness Improvement: {diffusion_results['Smoothness_Improvement']:.4f}")
        text_content.append(f"Image PSNR: {diffusion_results['Image_PSNR']:.2f} dB")
        text_content.append(f"Image SSIM: {diffusion_results['Image_SSIM']:.4f}")
        
        plt.text(0.05, 0.95, '\n'.join(text_content), transform=plt.gca().transAxes, 
                fontsize=8, verticalalignment='top', fontfamily='monospace')
        
        plt.subplot(3, 4, 12)
        plt.axis('off')
        
        # Display statistical information
        stats_content = []
        stats_content.append("=== Image Statistics ===\n")
        stats_content.append(f"Image 1 Size: {img1.shape}")
        stats_content.append(f"Image 2 Size: {img2.shape}")
        stats_content.append(f"Image 1 Mean: {np.mean(img1):.2f}")
        stats_content.append(f"Image 2 Mean: {np.mean(img2):.2f}")
        stats_content.append(f"Image 1 Std Dev: {np.std(img1):.2f}")
        stats_content.append(f"Image 2 Std Dev: {np.std(img2):.2f}")
        
        stats_content.append("\n=== Spectrum Statistics ===")
        stats_content.append(f"Spectrum 1 Total Energy: {np.sum(mag_spec1):.2e}")
        stats_content.append(f"Spectrum 2 Total Energy: {np.sum(mag_spec2):.2e}")
        stats_content.append(f"Spectrum Energy Change: {(np.sum(mag_spec2) - np.sum(mag_spec1))/np.sum(mag_spec1)*100:.2f}%")
        
        plt.text(0.05, 0.95, '\n'.join(stats_content), transform=plt.gca().transAxes, 
                fontsize=8, verticalalignment='top', fontfamily='monospace')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"Analysis results saved to: {save_path}")
        
        plt.show()
    
    def print_detailed_results(self, img1, img2, mag_spec1, mag_spec2):
        """Print detailed analysis results"""
        print("=" * 60)
        print("Spectrum Similarity Analysis Report")
        print("=" * 60)
        
        # Basic similarity analysis
        similarity_results = self.analyze_spectrum_similarity(mag_spec1, mag_spec2)
        print("\n📊 Basic Similarity Metrics:")
        print("-" * 30)
        for key, value in similarity_results.items():
            if key == 'MSE':
                print(f"{key:20}: {value:.6f} (smaller is more similar)")
            elif key == 'NMSE':
                print(f"{key:20}: {value:.6f} (smaller is more similar)")
            else:
                print(f"{key:20}: {value:.6f} (larger is more similar)")
        
        # Frequency band analysis
        band_results = self.analyze_frequency_bands(mag_spec1, mag_spec2)
        print("\n🔍 Frequency Band Analysis:")
        print("-" * 30)
        print(f"{'Low Freq Similarity':20}: {band_results['Low_Freq_Similarity']:.6f}")
        print(f"{'Mid Freq Similarity':20}: {band_results['Mid_Freq_Similarity']:.6f}")
        print(f"{'High Freq Similarity':20}: {band_results['High_Freq_Similarity']:.6f}")
        
        print(f"\nImage 1 Frequency Band Energy Distribution:")
        print(f"  Low Freq: {band_results['Low_Freq_Energy_Ratio1']:.4f}")
        print(f"  Mid Freq: {band_results['Mid_Freq_Energy_Ratio1']:.4f}")
        print(f"  High Freq: {band_results['High_Freq_Energy_Ratio1']:.4f}")
        
        print(f"\nImage 2 Frequency Band Energy Distribution:")
        print(f"  Low Freq: {band_results['Low_Freq_Energy_Ratio2']:.4f}")
        print(f"  Mid Freq: {band_results['Mid_Freq_Energy_Ratio2']:.4f}")
        print(f"  High Freq: {band_results['High_Freq_Energy_Ratio2']:.4f}")
        
        # Diffusion specific analysis
        diffusion_results = self.diffusion_specific_analysis(img1, img2, mag_spec1, mag_spec2)
        print("\n🎯 Diffusion Model Specific Analysis:")
        print("-" * 30)
        print(f"{'Noise Reduction Ratio':20}: {diffusion_results['Noise_Reduction_Ratio']:.6f}")
        if diffusion_results['Noise_Reduction_Ratio'] > 0:
            print("  → High frequency noise reduced ✓")
        else:
            print("  → High frequency energy increased")
            
        print(f"{'Spectral Smoothness':20}: {diffusion_results['Smoothness_Improvement']:.6f}")
        if diffusion_results['Smoothness_Improvement'] > 0:
            print("  → Spectrum became smoother ✓")
        else:
            print("  → Spectrum became rougher")
        
        print(f"{'Image PSNR':20}: {diffusion_results['Image_PSNR']:.2f} dB")
        print(f"{'Image SSIM':20}: {diffusion_results['Image_SSIM']:.6f}")
        print(f"{'Image MSE':20}: {diffusion_results['Image_MSE']:.6f}")
        
        # Comprehensive evaluation
        print("\n📈 Comprehensive Evaluation:")
        print("-" * 30)
        avg_similarity = np.mean([
            similarity_results['SSIM'],
            similarity_results['Correlation'],
            similarity_results['Cosine_Similarity']
        ])
        
        avg_freq_similarity = np.mean([
            band_results['Low_Freq_Similarity'],
            band_results['Mid_Freq_Similarity'],
            band_results['High_Freq_Similarity']
        ])
        
        print(f"Average Spectrum Similarity: {avg_similarity:.4f}")
        print(f"Average Frequency Band Similarity: {avg_freq_similarity:.4f}")
        
        if avg_similarity > 0.9:
            print("🟢 High spectrum similarity between two images")
        elif avg_similarity > 0.7:
            print("🟡 Moderate spectrum similarity between two images")
        else:
            print("🔴 Large spectrum difference between two images")
        
        print("=" * 60)
    
    def analyze_images(self, image_path1, image_path2, save_visualization=None, show_plot=True):
        """Main analysis function"""
        try:
            # Load images
            print(f"Loading images...")
            print(f"Image 1: {image_path1}")
            print(f"Image 2: {image_path2}")
            
            img1 = self.load_image(image_path1)
            img2 = self.load_image(image_path2)
            
            print(f"Image 1 size: {img1.shape}")
            print(f"Image 2 size: {img2.shape}")
            
            # Check if image dimensions are consistent
            if img1.shape != img2.shape:
                print("⚠️ Warning: Two images have different dimensions, resizing to match")
                min_h = min(img1.shape[0], img2.shape[0])
                min_w = min(img1.shape[1], img2.shape[1])
                img1 = cv2.resize(img1, (min_w, min_h))
                img2 = cv2.resize(img2, (min_w, min_h))
                print(f"Adjusted size: {img1.shape}")
            
            # Calculate spectrum
            print("Computing spectrum...")
            _, mag_spec1, _, log_spec1 = self.get_frequency_spectrum(img1)
            _, mag_spec2, _, log_spec2 = self.get_frequency_spectrum(img2)
            
            # Print detailed results
            self.print_detailed_results(img1, img2, mag_spec1, mag_spec2)
            
            # Visualize results
            if show_plot:
                print("Generating visualization results...")
                self.visualize_results(img1, img2, log_spec1, log_spec2, 
                                     mag_spec1, mag_spec2, save_visualization)
            
            return True
            
        except Exception as e:
            print(f"❌ Error occurred during analysis: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(description='Analyze spectrum similarity between two images')
    parser.add_argument('image1', help='First image path')
    parser.add_argument('image2', help='Second image path')
    parser.add_argument('--save', '-s', help='Path to save visualization results', default=None)
    parser.add_argument('--no-plot', action='store_true', help='Do not display graphical interface')
    
    args = parser.parse_args()
    
    # Check if files exist
    if not os.path.exists(args.image1):
        print(f"❌ Error: Cannot find file {args.image1}")
        sys.exit(1)
    
    if not os.path.exists(args.image2):
        print(f"❌ Error: Cannot find file {args.image2}")
        sys.exit(1)
    
    # Create analyzer and perform analysis
    analyzer = SpectrumAnalyzer()
    success = analyzer.analyze_images(
        args.image1, 
        args.image2, 
        save_visualization=args.save,
        show_plot=not args.no_plot
    )
    
    if success:
        print("\n✅ Analysis completed!")
        if args.save:
            print(f"📁 Results saved to: {args.save}")
    else:
        print("\n❌ Analysis failed!")
        sys.exit(1)

if __name__ == "__main__":
    main()